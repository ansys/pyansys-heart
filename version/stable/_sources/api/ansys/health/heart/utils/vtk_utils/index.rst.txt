





The ``vtk_utils.py`` module
===========================

.. py:module:: ansys.health.heart.utils.vtk_utils


Summary
-------








.. py:currentmodule:: vtk_utils
.. tab-set::







    .. tab-item:: Functions

        .. list-table::
          :header-rows: 0
          :widths: auto


          * - :py:obj:`~compute_surface_nodal_area_pyvista`
            - Compute an average nodal area by summing surface areas of connected elements.


          * - :py:obj:`~extrude_polydata`
            - Extrude a given polydata surface in a given direction.


          * - :py:obj:`~cell_ids_inside_enclosed_surface`
            - Get IDs of cells with centroids that are inside a given surface.


          * - :py:obj:`~find_cells_close_to_nodes`
            - Find cell IDs close to nodes.


          * - :py:obj:`~get_boundary_edges`
            - Get the boundary edges from an input surface.


          * - :py:obj:`~get_boundary_edge_loops`
            - Get the closed/open boundary edge loops of a surface mesh.


          * - :py:obj:`~get_patches_delaunay`
            - Patch boundary edges with the Delaunay algorithm.


          * - :py:obj:`~get_patches_with_centroid`
            - Patch boundary edges with a custom algorithm using a central node.


          * - :py:obj:`~are_connected`
            - Check whether two polydata or unstructured grid objects are connected.


          * - :py:obj:`~add_solid_name_to_stl`
            - Add the name of the solid to the STL file.


          * - :py:obj:`~find_corresponding_points`
            - Find corresponding points between two surfaces.


          * - :py:obj:`~generate_thickness_lines`
            - Generate lines from points on surface 1 to corresponding points on surface 2.

















Description
-----------

Module containing methods for mesh operations related to the VTK library.

..
    !! processed by numpydoc !!






Module detail
-------------

.. py:function:: compute_surface_nodal_area_pyvista(surface: pyvista.PolyData) -> numpy.ndarray

   
   Compute an average nodal area by summing surface areas of connected elements.


   :Parameters:

       **vtk_surface** : :obj:`vtk.vtkPolyData`
           VTK object describing the object.



   :Returns:

       :obj:`np.array`
           NumPy array with nodal areas of length number of points.








   .. rubric:: Notes

   This method adds the partial areas of connected elements/cells to each node.



   ..
       !! processed by numpydoc !!

.. py:function:: extrude_polydata(surface: pyvista.PolyData, extrude_by: float = 1, extrude_direction: numpy.ndarray = np.empty(0)) -> pyvista.PolyData

   
   Extrude a given polydata surface in a given direction.


   :Parameters:

       **surface** : :obj:`pv.PolyData`
           Surface to extrude

       **extrude_by** : :class:`python:float`, default: 1
           Amount to extrude.

       **extrude_direction** : :obj:`np.array`, default: :obj:`np.empty`\(0)
           Direction of extrusion, which should have three components. If no
           components are specified, it extrudes in the normal direction.



   :Returns:

       :obj:`pv.PolyData`
           Extruded polydata object.











   ..
       !! processed by numpydoc !!

.. py:function:: cell_ids_inside_enclosed_surface(source: pyvista.UnstructuredGrid | pyvista.PolyData, surface: pyvista.PolyData, tolerance: float = 1e-09) -> numpy.ndarray

   
   Get IDs of cells with centroids that are inside a given surface.


   :Parameters:

       **source** : :obj:`pv.UnstructuredGrid`
           Source object to check which cells are inside/outside
           the specified surface.

       **surface** : :obj:`pv.PolyData`
           Surface to check whether cells are inside/outside.

       **tolerance** : :class:`python:float`, default: 1e-9
           Tolerance for the ``select_enclosed_points`` filter.



   :Returns:

       :obj:`np.ndarray <numpy.ndarray>`
           Array with cell IDs that are inside the enclosed surface.








   .. rubric:: Notes

   This method also accepts a source that represents the cell centroids.
   In this case, computing the cell centers is skipped.



   ..
       !! processed by numpydoc !!

.. py:function:: find_cells_close_to_nodes(mesh: pyvista.UnstructuredGrid, node_ids: list[int], radius: float = 2) -> numpy.ndarray

   
   Find cell IDs close to nodes.


   :Parameters:

       **mesh** : :obj:`pv.UnstructuredGrid`
           Target mesh.

       **node_ids** : :class:`python:list`\[:class:`python:int`]
           Node IDs.

       **radius** : :class:`python:float`, default: 2
           Influence radius.



   :Returns:

       :obj:`np.ndarray <numpy.ndarray>`
           Cell IDs.











   ..
       !! processed by numpydoc !!

.. py:function:: get_boundary_edges(surface: pyvista.PolyData) -> pyvista.MultiBlock

   
   Get the boundary edges from an input surface.


   :Parameters:

       **surface** : :obj:`pv.PolyData`
           Surface to check for boundary edges.



   :Returns:

       :obj:`pv.MultiBlock`
           Multi-block data, where each block represents connected edges.











   ..
       !! processed by numpydoc !!

.. py:function:: get_boundary_edge_loops(surface: pyvista.PolyData, remove_open_edge_loops: bool = True, return_types: bool = False) -> dict | tuple[dict, dict]

   
   Get the closed/open boundary edge loops of a surface mesh.


   :Parameters:

       **surface** : :obj:`pv.PolyData`
           Surface mesh to check for boundary edges.

       **remove_open_edge_loops** : :ref:`bool <python:bltin-boolean-values>`, default: :data:`python:True`
           Whether to remove open edge loops from the returned dictionary.



   :Returns:

       :class:`python:dict`
           Dictionary with the edges that make up the open/closed loop.











   ..
       !! processed by numpydoc !!

.. py:function:: get_patches_delaunay(surface: pyvista.PolyData, closed_only: bool = True) -> list[pyvista.PolyData]

   
   Patch boundary edges with the Delaunay algorithm.


   :Parameters:

       **surface** : :obj:`pv.PolyData`
           Surface with boundary edges to find patches for.

       **closed_only** : :ref:`bool <python:bltin-boolean-values>`, default: :data:`python:True`
           Whether to return patches for closed loops of boundary edges.



   :Returns:

       :obj:`List`\[:obj:`pv.PolyData`]
           List of patches that close the open surface.











   ..
       !! processed by numpydoc !!

.. py:function:: get_patches_with_centroid(surface: pyvista.PolyData, closed_only: bool = True) -> list[pyvista.PolyData] | None

   
   Patch boundary edges with a custom algorithm using a central node.


   :Parameters:

       **surface** : :obj:`pv.PolyData`
           Surface with boundary edges to find patches for.

       **closed_only** : :ref:`bool <python:bltin-boolean-values>`, default: :data:`python:True`
           Whether to return patches for closed loops of boundary edges.



   :Returns:

       :obj:`List`\[:obj:`pv.PolyData`]
           List of patches that close the open surface.








   .. rubric:: Notes

   Edges must be sorted properly for this method to return sensible patches.



   ..
       !! processed by numpydoc !!

.. py:function:: are_connected(mesh1: pyvista.PolyData | pyvista.UnstructuredGrid, mesh2: pyvista.PolyData | pyvista.UnstructuredGrid) -> bool

   
   Check whether two polydata or unstructured grid objects are connected.


   :Parameters:

       **mesh1** : :obj:`Union`\[:obj:`pv.PolyData`, :obj:`pv.UnstructuredGrid`]
           First mesh.

       **mesh2** : :obj:`Union`\[:obj:`pv.PolyData`, :obj:`pv.UnstructuredGrid`]
           Second mesh.














   ..
       !! processed by numpydoc !!

.. py:function:: add_solid_name_to_stl(filename, solid_name, file_type: str = 'ascii') -> None

   
   Add the name of the solid to the STL file.













   .. rubric:: Notes

   This method supports only a single block.



   ..
       !! processed by numpydoc !!

.. py:function:: find_corresponding_points(first_surface: pyvista.PolyData, second_surface: pyvista.PolyData, distance: float = 20) -> numpy.ndarray

   
   Find corresponding points between two surfaces.


   :Parameters:

       **first_surface** : :obj:`pv.PolyData`
           First surface.

       **second_surface** : :obj:`pv.PolyData`
           Second surface.

       **distance** : :class:`python:float`
           Approximate largest distance between two surfaces.



   :Returns:

       :obj:`np.ndarray <numpy.ndarray>`
           2*N array
           The first row contains node IDs of the first surface.
           The second row contains corresponding node IDs on the second surface.
           If no corresponding node is found, ``None`` is returned.








   .. rubric:: Notes

   This method uses ray tracing.
   The two surfaces are assumed to be close and nearly parallel.
   As a result, the correspondence is not one to one. Some points might
   have no corresponding match, while others might share the same
   corresponding point.



   ..
       !! processed by numpydoc !!

.. py:function:: generate_thickness_lines(surface1: pyvista.PolyData, surface2: pyvista.PolyData, corresponding_points: numpy.ndarray = None) -> pyvista.PolyData

   
   Generate lines from points on surface 1 to corresponding points on surface 2.


   :Parameters:

       **surface1** : :obj:`pv.PolyData`
           First surface.

       **surface2** : :obj:`pv.PolyData`
           Second surface.

       **corresponding_points** : :obj:`np.ndarray <numpy.ndarray>`, default: :data:`python:None`
           Corresponding points array.



   :Returns:

       :obj:`pv.PolyData`
           Object contains cell data named ``thickness``.











   ..
       !! processed by numpydoc !!



